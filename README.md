# Print a page table (easy)

任务要求:

定义一个名为`vmprint()`的函数。它应该接受一个`pagetable_t`参数，并以下面描述的格式打印该页表。`在 exec.c 中的return argc`之前插入`if(p->pid==1) vmprint(p->pagetable)`，以打印第一个进程的页表。

第一行显示`vmprint`的参数。之后，每个 PTE 都有一行，包括引用树中更深的页表页面的 PTE。每个 PTE 行都缩进了一些`“..”`，表示它在树中的深度。每个 PTE 行显示其页表页中的 PTE 索引、pte 位和从 PTE 中提取的物理地址。不要打印无效的 PTE。在上面的示例中，顶级页表页具有条目 0 和 255 的映射。条目 0 的下一层仅映射了索引 0，而该索引 0 的底层具有条目 0、1 和2 映射。

1. 您可以将`vmprint()`放在`kernel/vm.c`中。
2. 使用文件 kernel/loongarch.h 末尾的宏。
3. `在 kernel/defs.h 中定义vmprint`的原型，以便您可以从 exec.c 中调用它。
4. 在您的 printf 调用中使用`%p`打印出完整的 64 位十六进制 PTE 和地址。

# A kernel page table per process (hard)

任务要求:

Xv6 有一个内核页表，每当它在内核中执行时都会使用它。内核页表直接映射到物理地址，因此内核虚拟地址*x*映射到物理地址*x*。Xv6 还为每个进程的用户地址空间提供了一个单独的页表，仅包含该进程的用户内存的映射，从虚拟地址零开始。因为内核页表不包含这些映射，所以用户地址在内核中是无效的。因此，当内核需要使用在系统调用中传递的用户指针时（例如，传递给`write() 的缓冲区指针）`)，内核必须首先将指针转换为物理地址。本节和下一节的目标是允许内核直接取消引用用户指针。

您的第一项工作是修改内核，以便每个进程在内核中执行时都使用自己的内核页表副本。修改`struct proc`为每个进程维护一个内核页表，并修改调度器在切换进程时切换内核页表。对于这一步，每个进程的内核页表应该与现有的全局内核页表相同。如果`usertests`运行正确，你就通过了这部分的实验。

- 为进程的内核页表 添加一个字段到`struct proc 。`
- 为新进程生成内核页表的合理方法是实现`kvminit`的修改版本，该版本生成新页表，而不是修改`kernel_pagetable`。您需要从`allocproc`调用此函数。
- 确保每个进程的内核页表都有该进程的内核堆栈的映射。在未修改的 xv6 中，所有内核堆栈都设置在`procinit`中。您需要将部分或全部功能移至`allocproc`。
- 修改`scheduler()`以将进程的内核页表加载到内核的`satp`寄存器中（请参阅`kvminithart`以获得灵感）。不要忘记在调用`w_satp()` 之后调用`sfence_vma()`。
- `scheduler()`应该在没有进程运行时 使用`kernel_pagetable 。`
- `在freeproc`中释放进程的内核页表。
- 您将需要一种方法来释放页表，而无需同时释放叶物理内存页面。
- `vmprint`在调试页表时可能会派上用场。
- 修改xv6功能或添加新功能都可以；您可能至少需要在`kernel/vm.c` 和`kernel/proc.c`中执行此操作。（但是，不要修改`kernel/vmcopyin.c`、`kernel/stats.c`、 `user/usertests.c`和`user/stats.c`。）
- 缺少页表映射可能会导致内核遇到页面错误。它将打印一个包含`sepc=0x00000000XXXXXXXXX`的错误。 您可以通过在`kernel/kernel.asm中搜索``XXXXXXXX`来找出故障发生的位置。

# Simplify `copyin/copyinstr` (hard)

内核的 `copyin`函数读取用户指针指向的内存。它通过将它们转换为物理地址来实现这一点，内核可以直接取消引用。它通过在软件中遍历进程页表来执行此转换。你在这部分实验中的工作是将用户映射添加到每个进程的内核页表（在上一节中创建），以允许 `copyin`（和相关的字符串函数 `copyinstr`）直接取消引用用户指针。

`将kernel/vm.c中的``copyin` 主体替换为对`copyin_new` 的调用（在 kernel `/vmcopyin.c`中定义）；`对copyinstr`和`copyinstr_new`执行相同的操作。将用户地址的映射添加到每个进程的内核页表，以便 `copyin_new`和`copyinstr_new`工作。

该方案依赖于用户虚拟地址范围，不与内核用于其自己的指令和数据的虚拟地址范围重叠。Xv6 使用从零开始的虚拟地址作为用户地址空间，幸运的是内核的内存从更高的地址开始。但是，这种方案确实将用户进程的最大大小限制为小于内核的最低虚拟地址。内核启动后，该地址是xv6 中的`0xC000000`，即 PLIC 寄存器的地址；请参见`kernel/vm.c`、 `kernel/memlayout.h`中的`kvminit()`。您需要修改 xv6 以防止用户进程变得大于 PLIC 地址。

一些提示：

- `先将copyin()`替换为对`copyin_new` 的调用，并使其工作，然后再转到`copyinstr`。
- 在内核更改进程的用户映射的每一点，都以相同的方式更改进程的内核页表。这些点包括`fork()`、`exec()`和`sbrk()`。
- 不要忘记在`userinit`的内核页表中包含第一个进程的用户页表。
- 用户地址的 PTE 在进程的内核页表中需要什么权限？（在内核模式下无法访问设置 了`PTE_U的页面。）`
- 不要忘记上述 PLIC 限制。
